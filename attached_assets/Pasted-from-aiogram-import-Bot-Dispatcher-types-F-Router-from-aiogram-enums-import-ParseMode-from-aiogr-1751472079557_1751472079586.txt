from aiogram import Bot, Dispatcher, types, F, Router
from aiogram.enums import ParseMode
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton
from aiogram.filters import Command, CommandStart
from aiogram.client.default import DefaultBotProperties
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
import asyncio
from keep_alive import keep_alive # Assuming keep_alive.py is in the same directory
from enum import Enum
from aiogram.fsm.storage.memory import MemoryStorage
from datetime import datetime

daily_order_counter = {} # Example: {"2023-10-27": 5}
order_number_to_user = {} # Example: {user_id1: order_num1, user_id2: order_num2}

API_TOKEN = "7582557120:AAGJKYgjXIocys3aZyNaVQlp_k892ARKBz0" # Consider using environment variables for tokens
ADMIN_ID = 1648127193 # Consider using environment variables
COURIERS_CHAT_ID = -1002297990202 # Consider using environment variables

# This variable is defined but not used anywhere in the provided code.
last_help_message_id = None

# --- Bot Initialization ---
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router() # Good practice to use a router
dp.include_router(router)

# --- Keyboards ---
main_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÇ –ö–∞—Ç–∞–ª–æ–≥"), KeyboardButton(text="üõç –ö–æ—Ä–∑–∏–Ω–∞")],
        [KeyboardButton(text="üì¶ –ú–æ–∏ –∑–∞–∫–∞–∑—ã"), KeyboardButton(text="üì¢ –ù–æ–≤–æ—Å—Ç–∏")],
        [KeyboardButton(text="‚≠êÔ∏è –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤"), KeyboardButton(text="‚ùì –ü–æ–º–æ—â—å")]
    ],
    resize_keyboard=True
)

# --- FSM States ---
class OrderForm(StatesGroup):
    waiting_for_location = State()
    confirm_address = State() # This state might be redundant or could be merged logic-wise
    waiting_for_phone = State()

class OrderStatus(Enum):
    ACCEPTED = "–í–∞—à –∑–∞–∫–∞–∑ –ø—Ä–∏–Ω—è—Ç"
    PREPARING = "–í–∞—à –∑–∞–∫–∞–∑ —Å–æ–±–∏—Ä–∞–µ—Ç—Å—è"
    ON_THE_WAY = "–í–∞—à –∑–∞–∫–∞–∑ –µ–¥–µ—Ç –∫ –≤–∞–º"
    DELIVERED = "–í–∞—à –∑–∞–∫–∞–∑ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω"

# --- In-memory Data Storage ---
# These will be lost on restart.
user_carts = {} # {user_id: {product_name: {"price": X, "quantity": Y}}}
user_orders = {} # {user_id: [{"status": OrderStatus.X, "text": "...", "order_number": N}]}

# Product catalog
products = {
    "category_fruits": {
        "–Ø–±–ª–æ–∫–æ": 3, "–ë–∞–Ω–∞–Ω": 4, "–ê–ø–µ–ª—å—Å–∏–Ω": 5, "–ì—Ä—É—à–∞": 4, "–í–∏–Ω–æ–≥—Ä–∞–¥": 8, 
        "–ú–∞–Ω–¥–∞—Ä–∏–Ω": 6, "–ö–∏–≤–∏": 7, "–ü–µ—Ä—Å–∏–∫": 6, "–ù–µ–∫—Ç–∞—Ä–∏–Ω": 6, "–°–ª–∏–≤–∞": 4
    },
    "category_vegetables": {
        "–ö–∞—Ä—Ç–æ—à–∫–∞": 2, "–ú–æ—Ä–∫–æ–≤—å": 1, "–û–≥—É—Ä–µ—Ü": 3, "–ü–æ–º–∏–¥–æ—Ä": 4, "–ö–∞–ø—É—Å—Ç–∞": 3,
        "–õ—É–∫": 2, "–ß–µ—Å–Ω–æ–∫": 3, "–ü–µ—Ä–µ—Ü": 5, "–ë–∞–∫–ª–∞–∂–∞–Ω": 4, "–ö–∞–±–∞—á–æ–∫": 3
    },
    "category_drinks": {
        "–ö–æ–ª–∞": 6, "–°–æ–∫": 5, "–í–æ–¥–∞": 2, "–§–∞–Ω—Ç–∞": 6, "–°–ø—Ä–∞–π—Ç": 6,
        "–ö–æ–º–ø–æ—Ç": 4, "–≠–Ω–µ—Ä–≥–µ—Ç–∏–∫": 8, "–ö–≤–∞—Å": 4, "–õ–∏–º–æ–Ω–∞–¥": 5, "–•–æ–ª–æ–¥–Ω—ã–π —á–∞–π": 4
    },
    "category_snacks": {
        "–ß–∏–ø—Å—ã": 4, "–®–æ–∫–æ–ª–∞–¥": 5, "–û—Ä–µ—Ö–∏": 6, "–°—É—Ö–∞—Ä–∏–∫–∏": 3, "–ü–µ—á–µ–Ω—å–µ": 4,
        "–í–∞—Ñ–ª–∏": 3, "–ö—Ä–µ–∫–µ—Ä—ã": 3, "–ü–æ–ø–∫–æ—Ä–Ω": 4, "–°–µ–º–µ—á–∫–∏": 2, "–ö–æ–Ω—Ñ–µ—Ç—ã": 5
    },
    "category_milks": {
        "–ú–æ–ª–æ–∫–æ": 18, "–°–º–µ—Ç–∞–Ω–∞": 14, "–ö–µ—Ñ–∏—Ä": 12, "–ô–æ–≥—É—Ä—Ç": 8, "–¢–≤–æ—Ä–æ–≥": 16,
        "–°—ã—Ä": 25, "–ú–∞—Å–ª–æ": 20, "–†—è–∂–µ–Ω–∫–∞": 15, "–ü—Ä–æ—Å—Ç–æ–∫–≤–∞—à–∞": 13, "–°–ª–∏–≤–∫–∏": 19
    }
}

# --- Command Handlers ---
@dp.message(CommandStart())
async def send_welcome(message: Message):
    user_id = message.from_user.id
    active_users.add(user_id) # Track user on /start

    kb = InlineKeyboardBuilder()
    kb.button(text="–§—Ä—É–∫—Ç—ã", callback_data="category_fruits")
    kb.button(text="–û–≤–æ—â–∏", callback_data="category_vegetables")
    kb.button(text="–ù–∞–ø–∏—Ç–∫–∏", callback_data="category_drinks")
    kb.button(text="–°–Ω–µ–∫–∏", callback_data="category_snacks")
    kb.button(text="–ú–æ–ª–æ—á–∫–∞", callback_data="category_milks")
    # It's good to adjust the layout for better readability on mobile
    kb.adjust(2,2,1) # Example: 2 buttons per row, last row has 1

    await message.answer(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ñ–¥—ë–º –≤–∞—à–∏—Ö –∑–∞–∫–∞–∑–æ–≤ üíú",
        reply_markup=main_menu
    )
    # Consider sending sticker and category selection in one go if possible, or ensure order.
    await bot.send_sticker(
        message.chat.id,
        "CAACAgQAAxkBAAIJT2gmdq7qFlY80egtqdn3Q0QPoA5iAAISDQAC1MiAUAXbnVAhxur0NgQ"
    )
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup=kb.as_markup())

@dp.message(Command("status"))
async def change_order_status(message: Message):
    if message.from_user.id != ADMIN_ID:
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    try:
        parts = message.text.split()
        if len(parts) != 3:
            # Provide more specific error message about format
            raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /status <–Ω–æ–º–µ—Ä_–∑–∞–∫–∞–∑–∞> <—Å—Ç–∞—Ç—É—Å>")

        _, order_number_str, status_str = parts
        order_number = int(order_number_str) # Can raise ValueError if not a number

        # Validate status_str before converting to OrderStatus
        valid_statuses = [s.name for s in OrderStatus]
        if status_str.upper() not in valid_statuses:
            raise ValueError(f"–ù–µ–≤–µ—Ä–Ω—ã–π —Å—Ç–∞—Ç—É—Å. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã: {', '.join(s.lower() for s in valid_statuses)}")

        status = OrderStatus[status_str.upper()]

        target_user_id = None
        order_to_update = None

        # Efficiently find the order and user
        for uid, orders_list in user_orders.items():
            for order_data in orders_list:
                if order_data.get("order_number") == order_number:
                    target_user_id = uid
                    order_to_update = order_data
                    break
            if target_user_id:
                break

        if target_user_id and order_to_update:
            order_to_update["status"] = status
            await bot.send_message(target_user_id, f"<b>–°—Ç–∞—Ç—É—Å –≤–∞—à–µ–≥–æ –∑–∞–∫–∞–∑–∞ #{order_number} –∏–∑–º–µ–Ω–µ–Ω: {status.value}</b>")
            await message.answer(f"–°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ ‚Ññ{order_number} –æ–±–Ω–æ–≤–ª—ë–Ω –Ω–∞: {status.value}")
        else:
            await message.answer(f"–ó–∞–∫–∞–∑ —Å –Ω–æ–º–µ—Ä–æ–º {order_number} –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    except ValueError as e: # Catch specific errors
        await message.answer(f"–û—à–∏–±–∫–∞: {e}")
    except Exception as e: # Catch any other unexpected errors
        await message.answer(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞.\n"
            "–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã: /status <–Ω–æ–º–µ—Ä_–∑–∞–∫–∞–∑–∞> <—Å—Ç–∞—Ç—É—Å>\n"
            f"–ù–∞–ø—Ä–∏–º–µ—Ä: /status 1 preparing\n"
            f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã: {', '.join(s.name.lower() for s in OrderStatus)}"
        )
        print(f"Error in change_order_status: {e}")


@dp.message(F.sticker)
async def get_sticker_id(message: Message):
    # It's good to also track users if they send a sticker and haven't started yet
    user_id = message.from_user.id
    active_users.add(user_id)

    if message.from_user.id == ADMIN_ID:
        await message.answer(f"file_id —Å—Ç–∏–∫–µ—Ä–∞:\n<code>{message.sticker.file_id}</code>")
    # Optional: else, you could reply to non-admins that this feature is admin-only or ignore.

# --- Callback Query Handlers ---
@dp.callback_query(lambda c: c.data.startswith("category_"))
async def show_category(callback: types.CallbackQuery):
    user_id = callback.from_user.id # Track user
    active_users.add(user_id)

    category_key = callback.data
    category_name_display = category_key.replace("category_", "").capitalize() # e.g., "Fruits"
    items = products.get(category_key, {})

    if not items:
        await callback.message.edit_text(f"–í –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ '{category_name_display}' –ø–æ–∫–∞ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.", reply_markup=InlineKeyboardBuilder().button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º", callback_data="back_to_categories").as_markup())
        await callback.answer()
        return

    kb = InlineKeyboardBuilder()
    for item, price in items.items():
        kb.button(text=f"{item} - {price} —Å–æ–º", callback_data=f"add_category_{category_key.replace('category_', '')}_{item}")

    # Adjust layout for better readability
    kb.adjust(1) # One item per row, or 2 if names are short

    kb.row(
        types.InlineKeyboardButton(text="üõí –ö–æ—Ä–∑–∏–Ω–∞", callback_data="cart"),
        types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_categories") # More descriptive callback
    )
    await callback.message.edit_text(f"<b>{category_name_display}</b>:", reply_markup=kb.as_markup())
    await callback.answer()

# Modified add_to_cart to use the refined callback_data
@dp.callback_query(lambda c: c.data.startswith("add_"))
async def add_to_cart(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    active_users.add(user_id)

    try:
        _, category, category_name, item_name = callback.data.split("_", 3)
        category_key = f"category_{category_name}"
    except ValueError:
        await callback.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–æ–≤–∞—Ä–∞.", show_alert=True)
        return

    category_items = products.get(category_key)
    if not category_items or item_name not in category_items:
        await callback.answer(f"–¢–æ–≤–∞—Ä '{item_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.", show_alert=True)
        return

    price = category_items[item_name]
    cart = user_carts.setdefault(user_id, {})

    if item_name in cart:
        cart[item_name]["quantity"] += 1
    else:
        cart[item_name] = {"price": price, "quantity": 1, "category": category_key} # Store category for "back"

    await callback.answer(f"{item_name} –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω—É!")
    # Optional: update cart message or offer to go to cart/continue shopping


@dp.callback_query(lambda c: c.data.startswith("increase_"))
async def increase_quantity(callback: types.CallbackQuery):
    item_name = callback.data.replace("increase_", "")
    user_id = callback.from_user.id
    active_users.add(user_id)
    cart = user_carts.get(user_id, {})

    if item_name in cart:
        cart[item_name]["quantity"] += 1
        await show_cart_logic(callback.message, user_id, edit_message=True) # Use a helper
        await callback.answer(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ {item_name} —É–≤–µ–ª–∏—á–µ–Ω–æ")
    else:
        await callback.answer("–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω–µ.", show_alert=True)


@dp.callback_query(lambda c: c.data.startswith("decrease_"))
async def decrease_quantity(callback: types.CallbackQuery):
    item_name = callback.data.replace("decrease_", "")
    user_id = callback.from_user.id
    active_users.add(user_id)
    cart = user_carts.get(user_id, {})

    if item_name in cart:
        if cart[item_name]["quantity"] > 1:
            cart[item_name]["quantity"] -= 1
        else:
            del cart[item_name] # Remove item if quantity becomes 0
        await show_cart_logic(callback.message, user_id, edit_message=True) # Use a helper
        await callback.answer(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ {item_name} —É–º–µ–Ω—å—à–µ–Ω–æ")
    else:
        await callback.answer("–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω–µ.", show_alert=True)


@dp.callback_query(lambda c: c.data.startswith("remove_"))
async def remove_from_cart(callback: types.CallbackQuery):
    item_to_remove = callback.data.replace("remove_", "")
    user_id = callback.from_user.id
    active_users.add(user_id)
    cart = user_carts.get(user_id, {})

    if item_to_remove in cart:
        del cart[item_to_remove]
        await show_cart_logic(callback.message, user_id, edit_message=True) # Use a helper
        await callback.answer(f"{item_to_remove} —É–¥–∞–ª–µ–Ω(–∞) –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã.")
    else:
        await callback.answer("–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.", show_alert=True)

# Helper function for showing cart to avoid code duplication
async def show_cart_logic(message_or_callback_message: types.Message, user_id: int, edit_message: bool = False):
    cart = user_carts.get(user_id, {})
    active_users.add(user_id)

    if not cart:
        text = "–ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞."
        kb = InlineKeyboardBuilder().button(text="‚¨ÖÔ∏è –ö –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º", callback_data="back_to_categories").as_markup()
        if edit_message:
            await message_or_callback_message.edit_text(text, reply_markup=kb)
        else:
            await message_or_callback_message.answer(text, reply_markup=kb)
        return

    text = "üõí <b>–í–∞—à–∞ –∫–æ—Ä–∑–∏–Ω–∞:</b>\n\n"
    total = 0
    kb = InlineKeyboardBuilder()

    first_item_category_key = None

    for item, data in cart.items():
        if not first_item_category_key and "category" in data:
            first_item_category_key = data["category"]
        price = data["price"]
        qty = data["quantity"]
        text += f"‚ñ™Ô∏è {item} ‚Äî {qty} x {price} = {qty * price} —Å–æ–º\n"
        total += qty * price
        kb.row(
            types.InlineKeyboardButton(text="‚ûñ", callback_data=f"decrease_{item}"),
            types.InlineKeyboardButton(text=f"{qty}", callback_data="noop"), # noop = no operation
            types.InlineKeyboardButton(text="‚ûï", callback_data=f"increase_{item}"),
            types.InlineKeyboardButton(text="‚ùå", callback_data=f"remove_{item}")
        )

    text += f"\n<b>–ò—Ç–æ–≥–æ: {total} —Å–æ–º</b>"

    # Navigation buttons
    back_button_data = "back_to_categories"
    back_button_text = "‚¨ÖÔ∏è –ö –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º"
    if first_item_category_key: # If we know a category, offer to go back there
        back_button_data = first_item_category_key # e.g. "category_fruits"
        back_button_text = f"‚¨ÖÔ∏è –ö {first_item_category_key.replace('category_', '').capitalize()}"

    kb.row(
        types.InlineKeyboardButton(text=back_button_text, callback_data=back_button_data),
        types.InlineKeyboardButton(text="‚úÖ –û—Ñ–æ—Ä–º–∏—Ç—å", callback_data="checkout")
    )
    kb.row(types.InlineKeyboardButton(text="üóë –û—á–∏—Å—Ç–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É", callback_data="clear_cart"))


    if edit_message:
        await message_or_callback_message.edit_text(text, reply_markup=kb.as_markup())
    else:
        await message_or_callback_message.answer(text, reply_markup=kb.as_markup())

@dp.callback_query(lambda c: c.data == "cart")
async def show_cart_callback(callback: types.CallbackQuery): # Renamed from show_cart to avoid conflict
    user_id = callback.from_user.id
    await show_cart_logic(callback.message, user_id, edit_message=True)
    await callback.answer()

@dp.callback_query(F.data == "clear_cart")
async def clear_cart_callback(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    if user_id in user_carts:
        user_carts[user_id] = {}
        await callback.answer("–ö–æ—Ä–∑–∏–Ω–∞ –æ—á–∏—â–µ–Ω–∞!", show_alert=True)
        # Show empty cart message
        await show_cart_logic(callback.message, user_id, edit_message=True)
    else:
        await callback.answer("–ö–æ—Ä–∑–∏–Ω–∞ —É–∂–µ –ø—É—Å—Ç–∞.", show_alert=True)


# --- Checkout Process (FSM) ---
@dp.callback_query(lambda c: c.data == "checkout")
async def checkout_start(callback: types.CallbackQuery, state: FSMContext): # Renamed from ask_location
    user_id = callback.from_user.id
    active_users.add(user_id)
    cart = user_carts.get(user_id, {})
    if not cart:
        await callback.answer("–í–∞—à–∞ –∫–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞. –ù–µ—á–µ–≥–æ –æ—Ñ–æ—Ä–º–ª—è—Ç—å.", show_alert=True)
        # Optionally, redirect to categories or show empty cart message
        await show_cart_logic(callback.message, user_id, edit_message=True)
        return

    kb = InlineKeyboardBuilder()
    kb.button(text="üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", callback_data="send_location_action") # More descriptive
    kb.button(text="üìù –í–≤–µ—Å—Ç–∏ –∞–¥—Ä–µ—Å –≤—Ä—É—á–Ω—É—é", callback_data="write_address_action")
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∫–æ—Ä–∑–∏–Ω—É", callback_data="cart") # Back to cart
    kb.adjust(1)
    await callback.message.edit_text(
        "<b>–û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞</b>\n–ö–∞–∫ –≤—ã —Ö–æ—Ç–∏—Ç–µ —É–∫–∞–∑–∞—Ç—å –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏?",
        reply_markup=kb.as_markup()
    )
    await state.set_state(OrderForm.waiting_for_location) # Initial state for address
    await callback.answer()

@dp.callback_query(lambda c: c.data == "send_location_action", OrderForm.waiting_for_location)
async def ask_geo_permission(callback: types.CallbackQuery, state: FSMContext): # Renamed
    # This reply keyboard is temporary and will be replaced by the main_menu later
    kb = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –º–æ—é –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", request_location=True)]
        ],
        resize_keyboard=True,
        one_time_keyboard=True # Important for this type of keyboard
    )
    await callback.message.answer(
        "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–∞—à—É –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é.",
        reply_markup=kb
    )
    # The state is already waiting_for_location, user will send a location message
    await callback.answer()

@dp.callback_query(lambda c: c.data == "write_address_action", OrderForm.waiting_for_location)
async def ask_manual_address_input(callback: types.CallbackQuery, state: FSMContext): # Renamed
    await callback.message.edit_text( # Edit previous message
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏ (—É–ª–∏—Ü–∞, –¥–æ–º, —ç—Ç–∞–∂, –∫–≤–∞—Ä—Ç–∏—Ä–∞, –æ—Ä–∏–µ–Ω—Ç–∏—Ä):",
        # No inline keyboard needed here, user will type.
        # Can add a "cancel" or "back" button if desired.
        reply_markup=InlineKeyboardBuilder().button(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="checkout_cancel").as_markup()
    )
    await state.set_state(OrderForm.confirm_address) # State for receiving manual address text
    await callback.answer()

# Handles location sent via button
@router.message(OrderForm.waiting_for_location, F.location)
async def process_location_sent(message: Message, state: FSMContext):
    latitude = message.location.latitude
    longitude = message.location.longitude
    # Using a more common map link format
    address = f"https://www.google.com/maps?q={latitude},{longitude}"
    # address = f"https://yandex.ru/maps/?ll={longitude}%2C{latitude}&z=18&l=map&pt={longitude},{latitude},pm2rdl"
    await state.update_data(address=address, address_type="location")

    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –î–∞, –≤–µ—Ä–Ω–æ", callback_data="confirm_address_yes")
    kb.button(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å", callback_data="confirm_address_no") # "No" implies re-enter/choose method
    await message.answer(
        f"–í–∞—à –∞–¥—Ä–µ—Å: <a href='{address}'>–ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ</a>\n–í–µ—Ä–Ω–æ?",
        reply_markup=kb.as_markup(),
        disable_web_page_preview=False # Allow preview for map link
    )

# Handles manually typed address
@router.message(OrderForm.confirm_address, F.text)
async def process_manual_address(message: Message, state: FSMContext):
    address = message.text
    if len(address) < 5: # Basic validation
        await message.reply("–ê–¥—Ä–µ—Å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω—ã–π –∞–¥—Ä–µ—Å –∏–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ.",
                            reply_markup=InlineKeyboardBuilder().button(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="checkout_cancel").as_markup())
        return

    # Create Yandex Maps link
    yandex_maps_query = f"https://yandex.ru/maps/?text={address.replace(' ', '+')}"
    await state.update_data(address=f'<a href="{yandex_maps_query}">{address}</a>', address_type="manual")
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –î–∞, –≤–µ—Ä–Ω–æ", callback_data="confirm_address_yes")
    kb.button(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å", callback_data="confirm_address_no")
    await message.answer(
        f"–í—ã —É–∫–∞–∑–∞–ª–∏ –∞–¥—Ä–µ—Å: <code>{address}</code>\n–í–µ—Ä–Ω–æ?",
        reply_markup=kb.as_markup()
    )
    # State is already confirm_address, or can transition to a dedicated confirmation state.

# General handler for unexpected input during address states
@router.message(OrderForm.waiting_for_location)
@router.message(OrderForm.confirm_address)
async def address_fallback_handler(message: Message, state: FSMContext):
    current_state = await state.get_state()
    if current_state == OrderForm.waiting_for_location.state:
        await message.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–∫–∏ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –≤–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ –≤—Ä—É—á–Ω—É—é.")
    elif current_state == OrderForm.confirm_address.state:
        await message.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –∞–¥—Ä–µ—Å —Ç–µ–∫—Å—Ç–æ–º –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ò–∑–º–µ–Ω–∏—Ç—å' –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥—Ä—É–≥–æ–≥–æ —Å–ø–æ—Å–æ–±–∞.")


@dp.callback_query(lambda c: c.data == "confirm_address_yes", OrderForm.waiting_for_location)
@dp.callback_query(lambda c: c.data == "confirm_address_yes", OrderForm.confirm_address)
async def address_confirmed_ask_phone(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.edit_text(
        "–ê–¥—Ä–µ—Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω. –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, +992XXXXXXXXX –∏–ª–∏ 90XXXXXXX):",
        reply_markup=InlineKeyboardBuilder().button(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="checkout_cancel").as_markup()
    )
    await state.set_state(OrderForm.waiting_for_phone)
    await callback.answer()

@dp.callback_query(lambda c: c.data == "confirm_address_no", OrderForm.waiting_for_location)
@dp.callback_query(lambda c: c.data == "confirm_address_no", OrderForm.confirm_address)
async def address_retry_choice(callback: types.CallbackQuery, state: FSMContext):
    # Go back to the initial choice of location vs manual
    kb = InlineKeyboardBuilder()
    kb.button(text="üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", callback_data="send_location_action")
    kb.button(text="üìù –í–≤–µ—Å—Ç–∏ –∞–¥—Ä–µ—Å –≤—Ä—É—á–Ω—É—é", callback_data="write_address_action")
    kb.button(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="checkout_cancel")
    kb.adjust(1)
    await callback.message.edit_text(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏ –µ—â–µ —Ä–∞–∑:",
        reply_markup=kb.as_markup()
    )
    await state.set_state(OrderForm.waiting_for_location) # Reset to initial address state
    await callback.answer()

@dp.callback_query(F.data == "checkout_cancel", OrderForm.waiting_for_location)
@dp.callback_query(F.data == "checkout_cancel", OrderForm.confirm_address)
@dp.callback_query(F.data == "checkout_cancel", OrderForm.waiting_for_phone)
async def checkout_cancel_process(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("–û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    # Show cart again or main menu
    await show_cart_logic(callback.message, callback.from_user.id, edit_message=False) # Send as new message
    await callback.answer("–û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")


@router.message(OrderForm.waiting_for_phone, F.text)
async def process_phone_and_complete_order(message: Message, state: FSMContext):
    phone = message.text
    # Basic phone validation (can be improved with regex)
    if not (phone.replace("+", "").isdigit() and len(phone.replace("+", "")) >= 7):
        await message.reply("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–µ–ª–µ—Ñ–æ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ.",
                            reply_markup=InlineKeyboardBuilder().button(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="checkout_cancel").as_markup())
        return

    data = await state.get_data()
    address = data.get("address", "–ù–µ —É–∫–∞–∑–∞–Ω") # Default if something went wrong
    user_id = message.from_user.id

    # Generate daily order number
    today = datetime.now().strftime("%Y-%m-%d")
    current_day_count = daily_order_counter.get(today, 0) + 1
    daily_order_counter[today] = current_day_count
    order_display_number = f"{datetime.now().strftime('%d%m')}-{current_day_count}"


    cart = user_carts.get(user_id, {})
    if not cart:
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –≤–∞—à–∞ –∫–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞. –ó–∞–∫–∞–∑ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ñ–æ—Ä–º–ª–µ–Ω.", reply_markup=main_menu)
        await state.clear()
        return

    order_items_text_parts = []
    total_amount = 0
    for item, item_data in cart.items():
        item_total = item_data['price'] * item_data['quantity']
        order_items_text_parts.append(
            f"- {item} x {item_data['quantity']} = {item_total} —Å–æ–º"
        )
        total_amount += item_total

    order_details_text = "\n".join(order_items_text_parts)

    # Construct message for user
    user_confirmation_text = (
        f"‚úÖ <b>–ó–∞–∫–∞–∑ #{order_display_number} —É—Å–ø–µ—à–Ω–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω!</b>\n\n"
        f"<b>–°–æ—Å—Ç–∞–≤ –∑–∞–∫–∞–∑–∞:</b>\n{order_details_text}\n\n"
        f"<b>–ò—Ç–æ–≥–æ –∫ –æ–ø–ª–∞—Ç–µ: {total_amount} —Å–æ–º</b>\n"
        f"<b>–ê–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏:</b> {address}\n"
        f"<b>–í–∞—à —Ç–µ–ª–µ—Ñ–æ–Ω:</b> {phone}\n\n"
        f"–°–ø–∞—Å–∏–±–æ –∑–∞ –∑–∞–∫–∞–∑! –ú—ã —Å–∫–æ—Ä–æ —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏. üíú"
    )

    # Clear cart for this user
    user_carts[user_id] = {}
    await message.answer(user_confirmation_text, reply_markup=main_menu) # Send with main keyboard

    # Prepare notification for admin and couriers
    user_info = message.from_user
    user_mention = f"@{user_info.username}" if user_info.username else f"ID <a href='tg://user?id={user_id}'>{user_id}</a>"

    admin_notification_text = (
        f"üîî <b>–ù–æ–≤—ã–π –∑–∞–∫–∞–∑ #{order_display_number}</b> –æ—Ç {user_mention}\n\n"
        f"<b>–°–æ—Å—Ç–∞–≤ –∑–∞–∫–∞–∑–∞:</b>\n{order_details_text}\n\n"
        f"<b>–ò—Ç–æ–≥–æ: {total_amount} —Å–æ–º</b>\n"
        f"<b>–ê–¥—Ä–µ—Å:</b> {address}\n"
        f"<b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> <code>{phone}</code> (–Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è)\n"
        f"<b>–í—Ä–µ–º—è:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    )

    # Create status management buttons
    status_kb = InlineKeyboardBuilder()
    status_kb.button(text="üîÑ –°–æ–±—Ä–∞—Ç—å –∑–∞–∫–∞–∑", callback_data=f"status_{order_display_number}_preparing")
    status_kb.button(text="üöó –û—Ç–¥–∞—Ç—å –∫—É—Ä—å–µ—Ä—É", callback_data=f"status_{order_display_number}_on_the_way")
    status_kb.button(text="‚úÖ –î–æ—Å—Ç–∞–≤–ª–µ–Ω", callback_data=f"status_{order_display_number}_delivered")
    status_kb.adjust(1)

    try:
        await bot.send_message(ADMIN_ID, admin_notification_text, reply_markup=status_kb.as_markup())
        await bot.send_message(COURIERS_CHAT_ID, admin_notification_text, reply_markup=status_kb.as_markup())
    except Exception as e:
        print(f"Error sending order notification: {e}")
        # Optionally notify admin that notification failed for couriers

    # Store the order
    user_orders.setdefault(user_id, []).append({
        "order_number": order_display_number, # Using the display number
        "status": OrderStatus.ACCEPTED,
        "details_for_user": user_confirmation_text, # Full text sent to user for /orders
        "details_for_admin": admin_notification_text, # For /active_orders
        "timestamp": datetime.now().isoformat()
    })


    await state.clear() # Clear FSM state

# --- Admin Commands ---
@dp.message(Command("active_orders"))
async def cmd_active_orders(message: Message):
    if message.from_user.id != ADMIN_ID:
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    active_orders_texts = []
    for user_id, orders_list in user_orders.items():
        for order_data in orders_list:
            # Define "active" statuses
            if order_data["status"] in [OrderStatus.ACCEPTED, OrderStatus.PREPARING, OrderStatus.ON_THE_WAY]:
                # Use the detailed admin notification text
                active_orders_texts.append(order_data.get("details_for_admin", f"–ó–∞–∫–∞–∑ #{order_data['order_number']} - –°—Ç–∞—Ç—É—Å: {order_data['status'].value}"))

    if not active_orders_texts:
        await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤.", reply_markup=main_menu)
        return

    response_header = "<b>–ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–∫–∞–∑—ã:</b>\n\n---\n\n"
    full_response = response_header + "\n\n---\n\n".join(active_orders_texts)

    # Telegram message length limit is 4096 characters. Split if necessary.
    if len(full_response) > 4096:
        await message.answer("–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –æ–¥–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –∏–ª–∏ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö.")
        # Or implement pagination
    else:
        await message.answer(full_response, reply_markup=main_menu)

# --- General User Commands & Menu Handlers ---
@dp.callback_query(lambda c: c.data == "back_to_categories") # Changed from "back"
async def go_back_to_categories(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    active_users.add(user_id)

    kb = InlineKeyboardBuilder()
    kb.button(text="–§—Ä—É–∫—Ç—ã", callback_data="category_fruits")
    kb.button(text="–û–≤–æ—â–∏", callback_data="category_vegetables")
    kb.button(text="–ù–∞–ø–∏—Ç–∫–∏", callback_data="category_drinks")
    kb.button(text="–°–Ω–µ–∫–∏", callback_data="category_snacks")
    kb.button(text="–ú–æ–ª–æ—á–∫–∞", callback_data="category_milks")
    kb.adjust(2,2,1) # Example layout

    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup=kb.as_markup())
    await callback.answer()

@dp.message(Command("cart")) # Handles /cart command
async def cmd_cart(message: Message):
    user_id = message.from_user.id
    await show_cart_logic(message, user_id, edit_message=False) # Send as new message

@dp.message(Command("orders"))
async def cmd_orders(message: Message):
    user_id = message.from_user.id
    active_users.add(user_id)

    user_specific_orders = user_orders.get(user_id, [])
    if not user_specific_orders:
        await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–∫–∞–∑–æ–≤.", reply_markup=main_menu)
        return

    response_parts = ["<b>–í–∞—à–∏ –∑–∞–∫–∞–∑—ã:</b>\n"]
    for order_data in reversed(user_specific_orders): # Show newest first
        # Using the text that was originally sent to the user for consistency
        order_text_for_user = order_data.get("details_for_user", # Fallback
                                           f"üì¶ <b>–ó–∞–∫–∞–∑ #{order_data['order_number']}</b>\n"
                                           f"–°—Ç–∞—Ç—É—Å: {order_data['status'].value}\n"
                                           f"–í—Ä–µ–º—è: {datetime.fromisoformat(order_data['timestamp']).strftime('%Y-%m-%d %H:%M') if 'timestamp' in order_data else 'N/A'}")

        # Append current status if not already in details_for_user or if it changed
        if "–°—Ç–∞—Ç—É—Å:" not in order_text_for_user or order_data['status'].value not in order_text_for_user :
             current_status_line = f"<b>–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: {order_data['status'].value}</b>"
             # Check if details_for_user already has a status line to replace or append
             lines = order_text_for_user.split('\n')
             status_line_exists = any("–°—Ç–∞—Ç—É—Å:" in line for line in lines) # Simple check
             if not status_line_exists:
                 order_text_for_user += f"\n{current_status_line}"
             # More complex logic could replace an existing status line if needed

        response_parts.append(order_text_for_user + "\n\n---\n")

    full_response = "\n".join(response_parts)
    if len(full_response) > 4096:
        await message.answer("–£ –≤–∞—Å —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–∫–∞–∑–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–∫–∞–∑–∞–Ω—ã –ø–æ—Å–ª–µ–¥–Ω–∏–µ.", reply_markup=main_menu)
        # Implement pagination or show only a few recent orders
    else:
        await message.answer(full_response, reply_markup=main_menu)

@dp.message(Command("help"))
async def cmd_help(message: Message):
    user_id = message.from_user.id
    active_users.add(user_id)
    help_text = """
<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏:</b>
/start - –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –∏ –ø–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.
/cart - –ü–æ–∫–∞–∑–∞—Ç—å –≤–∞—à—É –∫–æ—Ä–∑–∏–Ω—É.
/orders - –ü–æ–∫–∞–∑–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é –≤–∞—à–∏—Ö –∑–∞–∫–∞–∑–æ–≤.
/search <code>&lt;–∑–∞–ø—Ä–æ—Å&gt;</code> - –ü–æ–∏—Å–∫ —Ç–æ–≤–∞—Ä–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä: /search —è–±–ª–æ–∫–æ).
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.

<b>–ö–Ω–æ–ø–∫–∏ –≤ –º–µ–Ω—é:</b>
<b>üìÇ –ö–∞—Ç–∞–ª–æ–≥</b> - –ü—Ä–æ—Å–º–æ—Ç—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Ç–æ–≤–∞—Ä–æ–≤.
<b>üõç –ö–æ—Ä–∑–∏–Ω–∞</b> - –í–∞—à–∞ —Ç–µ–∫—É—â–∞—è –∫–æ—Ä–∑–∏–Ω–∞.
<b>üì¶ –ú–æ–∏ –∑–∞–∫–∞–∑—ã</b> - –ò—Å—Ç–æ—Ä–∏—è –≤–∞—à–∏—Ö –∑–∞–∫–∞–∑–æ–≤.
<b>üì¢ –ù–æ–≤–æ—Å—Ç–∏</b> - –ü–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –º–∞–≥–∞–∑–∏–Ω–∞ (–ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ).
<b>‚≠êÔ∏è –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤</b> - –û—Ü–µ–Ω–∏—Ç—å —Å–µ—Ä–≤–∏—Å –∏ –æ—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤.
<b>‚ùì –ü–æ–º–æ—â—å</b> - –ö–æ–Ω—Ç–∞–∫—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∞.
"""
    await message.answer(help_text, reply_markup=main_menu)

@dp.message(Command("search"))
async def search_products(message: Message):
    user_id = message.from_user.id
    active_users.add(user_id)
    search_query = message.text.replace("/search", "").strip().lower()
    if not search_query:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —á—Ç–æ –≤—ã –∏—â–µ—Ç–µ. –ù–∞–ø—Ä–∏–º–µ—Ä: <code>/search —è–±–ª–æ–∫–æ</code>")
        return

    results = []
    for category_key, items_dict in products.items():
        category_name = category_key.replace('category_', '').capitalize()
        for item_name, price in items_dict.items():
            if search_query in item_name.lower():
                # Add button to add to cart directly from search results
                kb_search = InlineKeyboardBuilder()
                kb_search.button(text=f"‚ûï –í –∫–æ—Ä–∑–∏–Ω—É", callback_data=f"add_{category_key}_{item_name}")
                results.append(
                    (f"‚ñ™Ô∏è {item_name} ‚Äî {price} —Å–æ–º ({category_name})", kb_search.as_markup())
                )

    if results:
        await message.answer("üîç <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞:</b>")
        for res_text, res_kb in results:
            await message.answer(res_text, reply_markup=res_kb)
    else:
        await message.answer("–ü–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ üòî")

# --- Text-based Menu Button Handlers ---
@dp.message(F.text == "üìÇ –ö–∞—Ç–∞–ª–æ–≥")
async def menu_catalog(message: Message):
    # await message.delete() # Deleting user message can sometimes be confusing
    user_id = message.from_user.id
    active_users.add(user_id)
    kb = InlineKeyboardBuilder()
    kb.button(text="–§—Ä—É–∫—Ç—ã", callback_data="category_fruits")
    kb.button(text="–û–≤–æ—â–∏", callback_data="category_vegetables")
    kb.button(text="–ù–∞–ø–∏—Ç–∫–∏", callback_data="category_drinks")
    kb.button(text="–°–Ω–µ–∫–∏", callback_data="category_snacks")
    kb.button(text="–ú–æ–ª–æ—á–∫–∞", callback_data="category_milks")
    kb.adjust(2,2,1)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup=kb.as_markup())

@dp.message(F.text == "üõç –ö–æ—Ä–∑–∏–Ω–∞")
async def menu_cart(message: Message):
    # await message.delete()
    await cmd_cart(message) # Re-use the /cart command logic

@dp.message(F.text == "üì¶ –ú–æ–∏ –∑–∞–∫–∞–∑—ã")
async def menu_orders(message: Message):
    # await message.delete()
    await cmd_orders(message) # Re-use the /orders command logic

@dp.message(F.text == "üì¢ –ù–æ–≤–æ—Å—Ç–∏")
async def menu_news(message: Message):
    # await message.delete()
    user_id = message.from_user.id
    active_users.add(user_id)
    await message.answer("–†–∞–∑–¥–µ–ª –Ω–æ–≤–æ—Å—Ç–µ–π –ø–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ. –°–ª–µ–¥–∏—Ç–µ –∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏! üì¢", reply_markup=main_menu)

# --- Review FSM ---
class ReviewState(StatesGroup):
    waiting_for_rating = State()
    waiting_for_text = State()

@dp.message(F.text == "‚≠êÔ∏è –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤")
async def menu_reviews_start(message: Message, state: FSMContext): # Renamed
    # await message.delete()
    user_id = message.from_user.id
    active_users.add(user_id)
    kb = InlineKeyboardBuilder()
    for i in range(1, 6): # 1 to 5 stars
        kb.button(text="‚≠ê" * i, callback_data=f"rate_{i}")
    kb.adjust(3, 2) # Layout for stars
    kb.row(types.InlineKeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="review_cancel"))
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ü–µ–Ω–∏—Ç–µ –Ω–∞—à —Å–µ—Ä–≤–∏—Å –æ—Ç 1 –¥–æ 5 –∑–≤–µ–∑–¥:", reply_markup=kb.as_markup())
    await state.set_state(ReviewState.waiting_for_rating)

@dp.callback_query(lambda c: c.data.startswith("rate_"), ReviewState.waiting_for_rating)
async def handle_rating_input(callback: types.CallbackQuery, state: FSMContext): # Renamed
    try:
        rating = int(callback.data.split("_")[1])
        if not 1 <= rating <= 5:
            raise ValueError("Invalid rating value")
    except (ValueError, IndexError):
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –æ—Ü–µ–Ω–∫–∞.", show_alert=True)
        return

    await state.update_data(rating=rating)
    await callback.message.edit_text(
        f"–í—ã –ø–æ—Å—Ç–∞–≤–∏–ª–∏ –æ—Ü–µ–Ω–∫—É: {'‚≠ê' * rating}\n–¢–µ–ø–µ—Ä—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –æ—Ç–∑—ã–≤:",
        reply_markup=InlineKeyboardBuilder().button(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="review_cancel").as_markup()
    )
    await state.set_state(ReviewState.waiting_for_text)
    await callback.answer()

@dp.message(ReviewState.waiting_for_text, F.text)
async def handle_review_text_input(message: Message, state: FSMContext): # Renamed
    data = await state.get_data()
    rating = data.get("rating", "N/A") # Default if rating somehow not set
    review_text = message.text

    if len(review_text) < 10: # Basic validation
        await message.reply("–í–∞—à –æ—Ç–∑—ã–≤ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–ø–∏—à–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ –∏–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ.",
                            reply_markup=InlineKeyboardBuilder().button(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="review_cancel").as_markup())
        return

    user_info = message.from_user
    user_mention = f"@{user_info.username}" if user_info.username else f"ID <a href='tg://user?id={user_info.id}'>{user_info.id}</a>"

    review_message_to_admin = (
        f"üìù <b>–ù–æ–≤—ã–π –æ—Ç–∑—ã–≤ –æ—Ç {user_mention}</b>\n"
        f"<b>–û—Ü–µ–Ω–∫–∞:</b> {'‚≠ê' * rating if isinstance(rating, int) else rating}\n"
        f"<b>–û—Ç–∑—ã–≤:</b>\n{review_text}"
    )
    try:
        await bot.send_message(ADMIN_ID, review_message_to_admin)
    except Exception as e:
        print(f"Error sending review to admin: {e}")

    await message.answer("–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –æ—Ç–∑—ã–≤! –ú—ã —Ü–µ–Ω–∏–º –≤–∞—à–µ –º–Ω–µ–Ω–∏–µ. üíú", reply_markup=main_menu)
    await state.clear()

@dp.callback_query(F.data == "review_cancel", ReviewState.waiting_for_rating)
@dp.callback_query(F.data == "review_cancel", ReviewState.waiting_for_text)
async def review_cancel_process(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("–û—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–∑—ã–≤–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    # await callback.message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=main_menu) # Optional: send new message
    await callback.answer("–û—Ç–∑—ã–≤ –æ—Ç–º–µ–Ω–µ–Ω.")


@dp.message(F.text == "‚ùì –ü–æ–º–æ—â—å")
async def menu_help_contact(message: Message): # Renamed
    # await message.delete()
    user_id = message.from_user.id
    active_users.add(user_id)
    kb = InlineKeyboardBuilder()
    kb.button(
        text="üí¨ –ù–∞–ø–∏—Å–∞—Ç—å –≤ Telegram",
        url="https://t.me/DilovarAkhi" # Make sure this is the correct contact
    )
    # You can add more contact methods if available

    await message.answer(
        "<b>üìû –ö–æ–Ω—Ç–∞–∫—Ç—ã –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –î–£–ß–ê–†–•–ê</b> üíú\n\n"
        "–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–æ–ø—Ä–æ—Å—ã, –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, –≤—ã –º–æ–∂–µ—Ç–µ —Å–≤—è–∑–∞—Ç—å—Å—è —Å –Ω–∞–º–∏:\n"
        "‚Ä¢ <b>Telegram:</b> @DilovarAkhi\n"
        "‚Ä¢ <b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> +992 971 84 48 84 (–∑–≤–æ–Ω–∫–∏/–º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã)\n\n" # Example number
        "–ú—ã –ø–æ—Å—Ç–∞—Ä–∞–µ–º—Å—è –ø–æ–º–æ—á—å –≤–∞–º –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ!",
        reply_markup=kb.as_markup(),
        parse_mode=ParseMode.HTML
    )

active_users = set()


@dp.message(Command("promote"))
async def send_promotion(message: Message):
    if message.from_user.id != ADMIN_ID:
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    promo_text = message.text.replace("/promote", "").strip()
    if not promo_text:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /promote <—Ç–µ–∫—Å—Ç –∞–∫—Ü–∏–∏>\n–ù–∞–ø—Ä–∏–º–µ—Ä: <code>/promote –°–∫–∏–¥–∫–∞ 20% –Ω–∞ –≤—Å–µ —Ñ—Ä—É–∫—Ç—ã!</code>")
        return

    if not active_users:
        await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.")
        return

    success_count = 0
    failed_count = 0
    # Create a copy for iteration in case the set changes (though unlikely here)
    users_to_message = list(active_users)

    await message.answer(f"–ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è {len(users_to_message)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...")

    for user_id in users_to_message:
        try:
            await bot.send_message(
                user_id,
                f"üéâ <b>–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç –î–£–ß–ê–†–•–ê!</b> üéâ\n\n{promo_text}\n\n–ñ–µ–ª–∞–µ–º –ø—Ä–∏—è—Ç–Ω—ã—Ö –ø–æ–∫—É–ø–æ–∫!",
                # reply_markup=main_menu # Sending main_menu might be intrusive here.
                # Consider a specific inline button like "–ö –∫–∞—Ç–∞–ª–æ–≥—É"
                reply_markup=InlineKeyboardBuilder().button(text="üéÅ –ü–µ—Ä–µ–π—Ç–∏ –∫ –∞–∫—Ü–∏—è–º", callback_data="category_fruits").as_markup() # Example
            )
            success_count += 1
        except Exception as e: # Catch specific exceptions like ChatNotFound, BotBlocked etc.
            print(f"Failed to send promo to {user_id}: {e}")
            failed_count += 1

        await asyncio.sleep(0.1) # Small delay to avoid hitting Telegram limits too hard

    await message.answer(f"üì¢ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n‚úÖ –£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {success_count}\n‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å: {failed_count}")

# --- Bot Startup ---
@dp.callback_query(lambda c: c.data.startswith("status_"))
async def handle_status_update(callback: types.CallbackQuery):
    try:
        parts = callback.data.split("_")
        if len(parts) != 3:
            raise ValueError("Invalid callback data format")
        _, order_number, new_status = parts
        new_status = new_status.upper()

        if new_status not in [status.name for status in OrderStatus]:
            await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞", show_alert=True)
            return

        # Find the order and update its status
        found = False
        for user_id, orders_list in user_orders.items():
            for order in orders_list:
                if order["order_number"] == order_number:
                    old_status = order["status"]
                    order["status"] = OrderStatus[new_status]
                    found = True

                    # Notify the customer
                    notification = f"üîî <b>–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫–∞–∑–∞ #{order_number}</b>\n{OrderStatus[new_status].value}"
                    await bot.send_message(user_id, notification)

                    # Update buttons in admin/courier messages
                    status_kb = InlineKeyboardBuilder()
                    remaining_statuses = []
                    if new_status == "PREPARING":
                        remaining_statuses = ["on_the_way", "delivered"]
                    elif new_status == "ON_THE_WAY":
                        remaining_statuses = ["delivered"]

                    for status in remaining_statuses:
                        button_text = "üöó –û—Ç–¥–∞—Ç—å –∫—É—Ä—å–µ—Ä—É" if status == "on_the_way" else "‚úÖ –î–æ—Å—Ç–∞–≤–ª–µ–Ω"
                        status_kb.button(text=button_text, callback_data=f"status_{order_number}_{status}")

                    new_message_text = callback.message.text + f"\n\n<b>–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å:</b> {OrderStatus[new_status].value}"

                    if remaining_statuses:
                        await callback.message.edit_text(new_message_text, reply_markup=status_kb.adjust(1).as_markup())
                    else:
                        await callback.message.edit_text(new_message_text)

                    break
            if found:
                break

        if not found:
            await callback.answer("–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return

        await callback.answer("–°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω")

    except Exception as e:
        print(f"Error updating order status: {e}")
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞", show_alert=True)

async def main():
    print("Bot is starting...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    keep_alive() # If you are using a service like Replit to keep the bot alive
    asyncio.run(main())
